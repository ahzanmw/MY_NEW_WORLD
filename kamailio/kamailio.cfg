#!KAMAILIO
# Kamailio (OpenSER) SIP Server v4.3 - default configuration script
#     - web: http://www.kamailio.org
#     - git: http://sip-router.org
#
# Direct your questions about this file to: <sr-users@lists.sip-router.org>
#
# Refer to the Core CookBook at http://www.kamailio.org/wiki/
# for an explanation of possible statements, functions and parameters.
#
# Several features can be enabled using '#!define WITH_FEATURE' directives:
#
# *** To run in debug mode: 
#     - define WITH_DEBUG
#
# *** To enable mysql: 
#     - define WITH_MYSQL
#
# *** To enable authentication execute:
#     - enable mysql
#     - define WITH_AUTH
#     - add users using 'kamctl'
#
# *** To enable IP authentication execute:
#     - enable mysql
#     - enable authentication
#     - define WITH_IPAUTH
#     - add IP addresses with group id '1' to 'address' table
#
# *** To enable persistent user location execute:
#     - enable mysql
#     - define WITH_USRLOCDB
#
# *** To enable presence server execute:
#     - enable mysql
#     - define WITH_PRESENCE
#
# *** To enable nat traversal execute:
#     - define WITH_NAT
#     - install RTPProxy: http://www.rtpproxy.org
#     - start RTPProxy:
#        rtpproxy -l _your_public_ip_ -s udp:localhost:7722
#     - option for NAT SIP OPTIONS keepalives: WITH_NATSIPPING
# *** To enable PSTN gateway routing execute:
#     - define WITH_PSTN
#     - set the value of pstn.gw_ip
#     - check route[PSTN] for regexp routing condition
#
# *** To enable database aliases lookup execute:
#     - enable mysql
#     - define WITH_ALIASDB
#
# *** To enable speed dial lookup execute:
#     - enable mysql
#     - define WITH_SPEEDDIAL
#
# *** To enable multi-domain support execute:
#     - enable mysql
#     - define WITH_MULTIDOMAIN
#
# *** To enable TLS support execute:
#     - adjust CFGDIR/tls.cfg as needed
#     - define WITH_TLS
#
# *** To enable XMLRPC support execute:
#     - define WITH_XMLRPC
#     - adjust route[XMLRPC] for access policy
#
# *** To enable anti-flood detection execute:
#     - adjust pike and htable=>ipban settings as needed (default is
#       block if more than 16 requests in 2 seconds and ban for 300 seconds)
#     - define WITH_ANTIFLOOD
#
# *** To block 3XX redirect replies execute:
#     - define WITH_BLOCK3XX
#
# *** To enable VoiceMail routing execute:
#     - define WITH_VOICEMAIL
#     - set the value of voicemail.srv_ip
#     - adjust the value of voicemail.srv_port
#
# *** To enhance accounting execute:
#     - enable mysql
#     - define WITH_ACCDB
#     - add following columns to database
#!ifdef ACCDB_COMMENT
  ALTER TABLE acc ADD COLUMN src_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN src_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN src_ip varchar(64) NOT NULL default '';
  ALTER TABLE acc ADD COLUMN dst_ouser VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN dst_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN dst_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_ip varchar(64) NOT NULL default '';
  ALTER TABLE missed_calls ADD COLUMN dst_ouser VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN dst_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN dst_domain VARCHAR(128) NOT NULL DEFAULT '';
#!endif

####### Include Local Config If Exists #########
import_file "kamailio-local.cfg"

####### Defined Values #########

# *** Value defines - IDs used later in config
#!define WITH_MYSQL
#!define WITH_AUTH
#!define WITH_USRLOCDB
#!define WITH_PRESENCE
#!define WITH_FREESWITCH
#!define WITH_NAT

#!substdef "!MY_IP_ADDR!104.131.105.163!g"
#!substdef "!MY_DOMAIN!104.131.105.163!g"
#!substdef "!MY_WS_PORT!5066!g"
#!substdef "!MY_WSS_PORT!443!g"
#!substdef "!MY_MSRP_PORT!9000!g"
#!substdef "!MY_WS_ADDR!tcp:MY_IP_ADDR:MY_WS_PORT!g"
#!substdef "!MY_WSS_ADDR!tls:MY_IP_ADDR:MY_WSS_PORT!g"
#!substdef "!MY_MSRP_ADDR!tls:MY_IP_ADDR:MY_MSRP_PORT!g"
#!substdef "!MSRP_MIN_EXPIRES!1800!g"
#!substdef "!MSRP_MAX_EXPIRES!3600!g"

##!define LOCAL_TEST_RUN
##!define WITH_TLS
#!define WITH_WEBSOCKETS
##!define WITH_MSRP

# *** Value defines - IDs used later in config
#!define DBURL "mysql://kamailio:kamailiorw@104.131.105.222/kamailio"
#!ifdef WITH_MYSQL
# - database URL - used to connect to database server by modules such
#       as: auth_db, acc, usrloc, a.s.o.
#!ifndef DBURL
#!define DBURL "mysql://kamailio:kamailiorw@104.131.105.222/kamailio"
#!endif
#!endif
#!ifdef WITH_MULTIDOMAIN
# - the value for 'use_domain' parameters
#!define MULTIDOMAIN 1
#!else
#!define MULTIDOMAIN 0
#!endif

# - flags
#   FLT_ - per transaction (message) flags
#	FLB_ - per branch flags
#!define FLT_ACC 1
#!define FLT_ACCMISSED 2
#!define FLT_ACCFAILED 3
#!define FLT_NATS 5

#!define FLB_NATB 6
#!define FLB_NATSIPPING 7

####### Global Parameters #########

### LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR
#!ifdef WITH_DEBUG
debug=4
log_stderror=yes
#!else
debug=2
#log_stderror=no
log_stderror=yes
#!endif

memdbg=5
memlog=5

log_facility=LOG_LOCAL0

fork=yes
children=4

/* uncomment the next line to disable TCP (default on) */
#disable_tcp=yes

/* uncomment the next line to disable the auto discovery of local aliases
   based on reverse DNS on IPs (default on) */
#auto_aliases=no

/* add local domain aliases */
#alias="sip.mydomain.com"

/* uncomment and configure the following line if you want Kamailio to 
   bind on a specific interface/port/proto (default bind on all available) */
#listen=udp:10.0.0.10:5060

/* port to listen to
 * - can be specified more than once if needed to listen on many ports */
port=5065

#!ifdef WITH_TLS
enable_tls=yes
#!endif

listen=MY_IP_ADDR
#!ifdef WITH_WEBSOCKETS
listen=MY_WS_ADDR
#!ifdef WITH_TLS
listen=MY_WSS_ADDR
#!endif
#!endif
#!ifdef WITH_MSRP
listen=MY_MSRP_ADDR
#!endif

tcp_accept_no_cl=yes
#tcp_rd_buf_size=16384

# life time of TCP connection when there is no traffic
# - a bit higher than registration expires to cope with UA behind NAT
tcp_connection_lifetime=3605

####### Custom Parameters #########

# These parameters can be modified runtime via RPC interface
# - see the documentation of 'cfg_rpc' module.
#
# Format: group.id = value 'desc' description
# Access: $sel(cfg_get.group.id) or @cfg_get.group.id
#

#!ifdef WITH_PSTN
# PSTN GW Routing
#
# - pstn.gw_ip: valid IP or hostname as string value, example:
# pstn.gw_ip = "10.0.0.101" desc "My PSTN GW Address"
#
# - by default is empty to avoid misrouting
pstn.gw_ip = "" desc "PSTN GW Address"
pstn.gw_port = "" desc "PSTN GW Port"
#!endif

#!ifdef WITH_VOICEMAIL
# VoiceMail Routing on offline, busy or no answer
#
# - by default Voicemail server IP is empty to avoid misrouting
voicemail.srv_ip = "" desc "VoiceMail IP Address"
voicemail.srv_port = "5060" desc "VoiceMail Port"
#!endif



#AChintha EDITED -----
#-#!ifdef WITH_WEBSOCKETS
#MY_WS_ADDR = "tcp:104.131.105.163:5066" desc "public ip address"


#!ifdef WITH_FREESWITCH
freeswitch.bindip = "45.55.205.92" desc "Asterisk IP Address"
freeswitch.bindport = "8888" desc "Asterisk Port"
#fs.bindip = "45.55.205.92" desc "Asterisk IP Address"
#fs.bindport = "8888" desc "Asterisk Port"
#kamailio.bindip = "45.55.205.92" desc "Kamailio IP Address"
#kamailio.bindport = "5060" desc "Kamailio Port"
#!endif




####### Modules Section ########

# set paths to location of modules (to sources or installation folders)
#!ifdef WITH_SRCPATH
mpath="modules/"
#!else
mpath="/usr/local/lib64/kamailio/modules/"
#!endif

#!ifdef WITH_MYSQL
loadmodule "db_mysql.so"
#!endif

loadmodule "mi_fifo.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
#loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "mi_rpc.so"
loadmodule "acc.so"
loadmodule "domain.so"

#!ifdef WITH_AUTH
loadmodule "auth.so"
loadmodule "auth_db.so"
#!ifdef WITH_IPAUTH
loadmodule "permissions.so"
#!endif
#!endif

#!ifdef WITH_ALIASDB
loadmodule "alias_db.so"
#!endif

#!ifdef WITH_SPEEDDIAL
loadmodule "speeddial.so"
#!endif

#!ifdef WITH_MULTIDOMAIN
#loadmodule "domain.so"
#!endif

#!ifdef WITH_PRESENCE

#loadmodule "pua.so"
loadmodule "presence.so"
#loadmodule "xcap_client.so"
loadmodule "presence_xml.so"
loadmodule "xhttp.so"
loadmodule "xcap_server.so"
#loadmodule "rls.so"

#!endif

#!ifdef WITH_NAT
loadmodule "nathelper.so"
loadmodule "rtpproxy.so"
#loadmodule "rtpengine.so"
#!endif

#!ifdef WITH_TLS
loadmodule "tls.so"
#!endif

#!ifdef WITH_MSRP
loadmodule "msrp.so"
loadmodule "htable.so"
loadmodule "cfgutils.so"
#!endif
 
#!ifdef WITH_WEBSOCKETS
#loadmodule "xhttp.so"
loadmodule "websocket.so"
#loadmodule "nathelper.so"
#!endif

#!ifdef WITH_ANTIFLOOD
loadmodule "htable.so"
loadmodule "pike.so"
#!endif

#!ifdef WITH_XMLRPC
loadmodule "xmlrpc.so"
#!endif

#!ifdef WITH_DEBUG
loadmodule "debugger.so"
#!endif

#!ifdef WITH_FREESWITCH
loadmodule "uac.so"
#!endif



# ----------------- setting module-specific parameters ---------------


# ----- mi_fifo params -----
modparam("mi_fifo", "fifo_name", "/var/run/kamailio/kamailio_fifo");
#modparam("mi_fifo", "fifo_name", "/var/run/kamailio/kamailio_fifo")

# ----- ctl params -----
#modparam("ctl", "binrpc", "unix:/var/run/kamailio/kamailio_ctl")

# ----- tm params -----
# auto-discard branches from previous serial forking leg
modparam("tm", "failure_reply_mode", 3)
# default retransmission timeout: 30sec
modparam("tm", "fr_timer", 30000)
# default invite retransmission timeout after 1xx: 120sec
modparam("tm", "fr_inv_timer", 120000)


# ----- rr params -----
# set next param to 1 to add value to ;lr param (helps with some UAs)
modparam("rr", "enable_full_lr", 0)
# do not append from tag to the RR (no need for this script)
modparam("rr", "append_fromtag", 1)

# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
/* uncomment the next line to disable parallel forking via location */
# modparam("registrar", "append_branches", 0)
/* uncomment the next line not to allow more than 10 contacts per AOR */
#modparam("registrar", "max_contacts", 10)
# max value for expires of registrations
modparam("registrar", "max_expires", 3600)
# set it to 1 to enable GRUU
modparam("registrar", "gruu_enabled", 0)


# ----- acc params -----
/* what special events should be accounted ? */
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
/* by default ww do not adjust the direct of the sequential requests.
   if you enable this parameter, be sure the enable "append_fromtag"
   in "rr" module */
modparam("acc", "detect_direction", 0)
/* account triggers (flags) */
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "log_missed_flag", FLT_ACCMISSED)
modparam("acc", "log_extra", 
	"src_user=$fU;src_domain=$fd;src_ip=$si;"
	"dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
/* enhanced DB accounting */
#!ifdef WITH_ACCDB
modparam("acc", "db_flag", FLT_ACC)
modparam("acc", "db_missed_flag", FLT_ACCMISSED)
modparam("acc", "db_url", DBURL)
modparam("acc", "db_extra",
	"src_user=$fU;src_domain=$fd;src_ip=$si;"
	"dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")
#!endif


# ----- usrloc params -----
/* enable DB persistency for location entries */
#!ifdef WITH_USRLOCDB
modparam("usrloc", "db_url", DBURL)
modparam("usrloc", "db_mode", 3)
#modparam("usrloc", "use_domain", 1)
#modparam("usrloc", "use_domain", MULTIDOMAIN)
#modparam("usrloc", "db_insert_null", 1)
#modparam("usrloc", "db_update_as_insert", 1)
#!endif


# ----- auth_db params -----
#!ifdef WITH_AUTH
modparam("auth_db", "db_url", DBURL)
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "load_credentials", "")
#modparam("auth_db", "use_domain", 1)
#!endif
#modparam("auth_db", "use_domain", MULTIDOMAIN)

# ----- permissions params -----
#!ifdef WITH_IPAUTH
modparam("permissions", "db_url", DBURL)
modparam("permissions", "db_mode", 1)
#!endif




# ----- alias_db params -----
#!ifdef WITH_ALIASDB
modparam("alias_db", "db_url", DBURL)
modparam("alias_db", "use_domain", MULTIDOMAIN)
#!endif


# ----- speeddial params -----
#!ifdef WITH_SPEEDDIAL
modparam("speeddial", "db_url", DBURL)
modparam("speeddial", "use_domain", MULTIDOMAIN)
#!endif


# ----- domain params -----
modparam("domain", "db_url", DBURL)
# register callback to match myself condition with domains list
modparam("domain", "register_myself", 1)


#!ifdef WITH_PRESENCE
# ----- presence params -----
modparam("presence", "db_url", DBURL)
#modparam("xcap_client", "db_url", DBURL)
#modparam("xcap_client", "periodical_query", 1)
#modparam("xcap_client", "query_period", 30)

# ----- presence_xml params -----
modparam("presence_xml", "db_url", DBURL)
#modparam("presence_xml", "force_active", 0)
#modparam("presence_xml", "disable_bla", 0)
modparam("presence_xml", "integrated_xcap_server", 1)
modparam("xcap_server", "db_url", DBURL)
#!endif


#!ifdef WITH_NAT
# ----- rtpproxy params -----
modparam("rtpproxy", "rtpproxy_sock", "udp:localhost:7722")
#modparam("rtpproxy", "rtpproxy_sock", "udp:45.55.205.92:12222")
modparam("rtpproxy", "rtpproxy_retr", 2)
modparam("rtpproxy", "ice_candidate_priority_avp", "$avp(ice_priority)")

# ----- rtpengine params -----
#modparam("rtpengine", "rtpengine_sock", "udp:104.131.105.163:12222")
#modparam("rtpengine", "rtpengine_retr", 2)


# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.org")

# params needed for NAT traversal in other modules
#modparam("registrar","received_avp", "$avp(i:42)")
#modparam("nathelper","received_avp", "$avp(i:42)")
modparam("nathelper|registrar", "received_avp", "$avp(RECEIVED)")
modparam("usrloc", "nat_bflag", FLB_NATB)
#modparam("registrar", "received_param", "rcv")
#!endif


#!ifdef WITH_TLS
# ----- tls params -----
modparam("tls", "config", "/usr/local/etc/kamailio/tls.cfg")
#!endif

#!ifdef WITH_WEBSOCKETS
# ----- nathelper params -----
modparam("nathelper|registrar", "received_avp", "$avp(RECEIVED)")
# Note: leaving NAT pings turned off here as nathelper is _only_ being used for
#       WebSocket connections.  NAT pings are not needed as WebSockets have
#       their own keep-alives.
#!endif
 
#!ifdef WITH_MSRP
# ----- htable params -----
modparam("htable", "htable", "msrp=>size=8;autoexpire=MSRP_MAX_EXPIRES;")
#!endif

#!ifdef WITH_ANTIFLOOD
# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# ----- htable params -----
# ip ban htable with autoexpire after 5 minutes
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")
#!endif

#!ifdef WITH_XMLRPC
# ----- xmlrpc params -----
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC")
#!endif

#!ifdef WITH_DEBUG
# ----- debugger params -----
modparam("debugger", "cfgtrace", 1)
modparam("debugger", "log_level_name", "exec")
#!endif


####### Routing Logic ########


# Main SIP request routing logic
# - processing of any incoming SIP request starts with this route
# - note: this is the same as route { ... }
#- Achintha Commented
request_route {
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-----------1 \033[0m \n");
#xlog("L_INFO", "SIP Request: method >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> [$rm] from [$fu] to [$tu]\n");
	# per request initial checks
	route(REQINIT);

#-#!ifdef WITH_WEBSOCKETS
#  if (nat_uac_test(64)) {
#    # Do NAT traversal stuff for requests from a WebSocket
#    # connection - even if it is not behind a NAT!
#    # This won't be needed in the future if Kamailio and the
#    # WebSocket client support Outbound and Path.
#xlog("L_ERR", "Error aliasing contact------MMMMMMMMMM\n");
#    force_rport();
#    if (is_method("REGISTER")) 
#	{
#	xlog("L_ERR", "Error aliasing contact-----NNNNNNN\n");
#	fix_nated_register();
#	} 
#	else 
#	{
#      	#if (!add_contact_alias()) {
#        xlog("L_ERR", "Error aliasing contact <$ct>\n");
#        #sl_send_reply("400", "Bad Request");
#	if(is_first_hop())
#	set_contact_alias();
#      #  exit;
#      	}
#	setflag(FLT_NATS);
#   
# }
#-#!endif
 
  # NAT detection
  route(NATDETECT);

	# CANCEL processing
	if (is_method("CANCEL")) {
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-----------2  \033[0m \n");
		if (t_check_trans()) {
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-----------3 \033[0m \n");
			route(RELAY);
		}
		exit;
	}

	# handle requests within SIP dialogs
	route(WITHINDLG);

	### only initial requests (no To tag)

	# handle retransmissions
	if(t_precheck_trans()) {
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-----------4 \033[0m \n");
		t_check_trans();
		exit;
	}
	t_check_trans();

	# authentication
	route(AUTH);

	# record routing for dialog forming requests (in case they are routed)
	# - remove preloaded route headers
	remove_hf("Route");
	if (is_method("INVITE|SUBSCRIBE"))
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-----------5 \033[0m \n");
		record_route();

	# account only INVITEs
	if (is_method("INVITE")) {
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-----------6 \033[0m \n");
		setflag(FLT_ACC); # do accounting
	}

#custom routing dvp
	route(DVPROUTE);
	# dispatch requests to foreign domains
	#route(SIPOUT);

	### requests for my local domains

	# handle presence related requests
	route(PRESENCE);

	# handle registrations
	route(REGISTRAR);

	if ($rU==$null) {
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-----------7 \033[0m \n");
		# request with no Username in RURI
		sl_send_reply("484","Address Incomplete");
		exit;
	}

	# dispatch destinations to PSTN
	route(PSTN);

	# user location service
	route(LOCATION);
}

# Wrapper for relaying requests
route[RELAY] {

xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-----RELAY------8 \033[0m \n");
	# enable additional event routes for forwarded requests
	# - serial forking, RTP relaying handling, a.s.o.
	if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>----RELAY-------9 \033[0m \n");
		if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
	}
	if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-----RELAY------10 \033[0m \n");
		if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
	}
	if (is_method("INVITE")) {
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>------RELAY-----11 \033[0m \n");
		if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
	}

	if (!t_relay()) {
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-----RELAY------12 \033[0m \n");
		sl_reply_error();
	}
	exit;
}

# Per SIP request initial checks
route[REQINIT] {
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-----REQINIT------13_1\033[0m \n");
#!ifdef WITH_ANTIFLOOD
	# flood dection from same IP and traffic ban for a while
	# be sure you exclude checking trusted peers, such as pstn gateways
	# - local host excluded (e.g., loop to self)
	if(src_ip!=myself) {
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-----REQINIT------13\033[0m \n");
		if($sht(ipban=>$si)!=$null) {
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>------REQINIT-----14\033[0m \n");
			# ip is already blocked
			xdbg("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
			exit;
		}
		if (!pike_check_req()) {
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-----REQINIT------15 \033[0m \n");
			xlog("L_ALERT","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
			$sht(ipban=>$si) = 1;
			exit;
		}
	}
	if($ua =~ "friendly-scanner") {
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-----REQINIT------16 \033[0m \n");
		sl_send_reply("200", "OK");
		exit;
	}
#!endif

	if (!mf_process_maxfwd_header("10")) {
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>------REQINIT-----17 \033[0m \n");
		sl_send_reply("483","Too Many Hops");
		exit;
	}

	if(is_method("OPTIONS") && uri==myself && $rU==$null) {
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-----REQINIT------18 \033[0m \n");
		sl_send_reply("200","Keepalive");
		exit;
	}

	if(!sanity_check("1511", "7")) {
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-----REQINIT------19 \033[0m \n");
		xlog("Malformed SIP message from $si:$sp\n");
		exit;
	}
}

# Handle Custom Routing
route[DVPROUTE]
{
	if(is_method("INVITE"))
	{
         	xlog("==================================================DVP ROUTE=====================================================");
		if (is_from_local())
	        {
			xlog("==================================================FROM LOCAL SERVERS=====================================================");
        	        #REQUEST FROM FREESWITCH SERVERS
			if($hdr(DVP-DESTINATION-TYPE) == 'PUBLIC_USER')
			{
				route(LOCATION);
			}
			if($hdr(DVP-DESTINATION-TYPE) == 'GATEWAY')
			{
				#Gateway routing 
				route(RELAY);
			}
			else
			{
				xlog("=================================================CUSTOM HEADER NOT FOUND=====================================================");
				return;
			}


        	}
		else
		{
			xlog("==================================================NOT FROM LOCAL SERVERS=====================================================");
			return;
		}



	}
	return;
}
# Handle requests within SIP dialogs
route[WITHINDLG] {
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-----WITHINDLG------20_1 \033[0m \n");	
if (!has_totag()) return;

	# sequential request withing a dialog should
	# take the path determined by record-routing
if (loose_route()) 
{
#!ifdef WITH_WEBSOCKETS
     if ($du == "") 
	{
         if (!handle_ruri_alias()) 
		{
                xlog("L_ERR", "Bad alias <$ru>\n");
                sl_send_reply("400", "Bad Request");
                exit;
        }
    }
#!endif	
	route(DLGURI);
	if (is_method("BYE")) 
	{
	  setflag(FLT_ACC); # do accounting ...
      setflag(FLT_ACCFAILED); # ... even if the transaction fails
    }
	else if ( is_method("ACK")){
		# ACK is forwarded statelessy
		xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-----WITHINDLG----route(NATMANAGE) \033[0m \n");
        route(NATMANAGE);
	}
	else if ( is_method("NOTIFY") ) 
	{
        # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
		xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-----WITHINDLG----Record-Route \033[0m \n");
        record_route();
    }
	   route(RELAY);
}
else
{
	if (is_method("SUBSCRIBE") && uri == myself) 
	{
        # in-dialog subscribe requests
		xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-----WITHINDLG----route(PRESENCE) \033[0m \n");
        route(PRESENCE);
        exit;
    }
    if ( is_method("ACK") ) 
	{
        if ( t_check_trans() ) 
		{
          # no loose-route, but stateful ACK;
          # must be an ACK after a 487
          # or e.g. 404 from upstream server
		  xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-----WITHINDLG----route(RELAY) \033[0m \n");
          route(RELAY);
          exit;
        } 
		else 
		{
          # ACK without matching transaction ... ignore and discard
          exit;
        }
    }
      sl_send_reply("404","Not here");
    }
    exit;
}

# Handle SIP registrations
route[REGISTRAR] 
{
if (!is_method("REGISTER")) return;

	if(isflagset(FLT_NATS)) 
	{
		setbflag(FLB_NATB);
#!ifdef WITH_NATSIPPING
		# do SIP NAT pinging
		setbflag(FLB_NATSIPPING);
#!endif
	}
	xlog("=================================REGISTER==============================");	
	if (!save("location","0x00"))
	{
		sl_reply_error();
	}
        else{
  		xlog("=========================REGISTER DONE==================================");
	}	
	exit;
#-------commented by dinusha - due to conflict------------------------------------
#!ifdef WITH_FREESWITCH
		#route(REGFWD);
#!endif
#---------------------------------------------------------------
}


# User location service
route[LOCATION] 
{

xlog("==============================LOCATION ROUTE - $ru ===============================");

#!ifdef WITH_SPEEDDIAL
	# search for short dialing - 2-digit extension
	if($rU=~"^[0-9][0-9]$")
		if(sd_lookup("speed_dial"))
		xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-----LOCATION--SPEEDDIAL--route(SIPOUT) \033[0m \n");
			route(SIPOUT);
#!endif

#!ifdef WITH_ALIASDB
	# search in DB-based aliases
	if(alias_db_lookup("dbaliases"))
	xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-----LOCATION--ALIASDB--route(SIPOUT) \033[0m \n");
		route(SIPOUT);
#!endif

	$avp(oexten) = $rU;

	if (pres_check_basic("$ru", "open"))
        {
		pres_check_activities("$ru", "busy");
                if ($retcode == 1)
                {
                    send_reply("486", "Busy Here");
                    exit;
                }
                else
                {
                        xlog("=========================USER AVAILABLE - ALLOWED=====================================");
                        if (!lookup("location"))
                        {
                                $var(rc) = $rc;
                                route(TOVOICEMAIL);
                                t_newtran();

                                switch ($var(rc))
                                {
                                        case -1:
                                        case -3:
                                                send_reply("404", "Not Found");
                                                exit;
                                        case -2:
                                                send_reply("405", "Method Not Allowed");
                                                exit;
                                }
                        }
                }
        
        }
	else
        {
		xlog("=========================USER WITHOUT PRESENECE=====================================");

                        if (!lookup("location"))
                        {
                                $var(rc) = $rc;
                                route(TOVOICEMAIL);
                                t_newtran();

                                switch ($var(rc))
                                {
                                        case -1:
                                        case -3:
                                                send_reply("404", "Not Found");
                                                exit;
                                        case -2:
                                                send_reply("405", "Method Not Allowed");
                                                exit;
                                }
                        }

                #xlog("=========================USER UNAVAILABLE - NOT ALLOWED - RU : $ru =========================================");
                #send_reply("404", "Not Found");
        }
	

	# when routing via usrloc, log the missed calls also
	if (is_method("INVITE")) 
	{
		setflag(FLT_ACCMISSED);	

	}

	route(RELAY);
	exit;
}

# Presence server processing
route[PRESENCE] 
{
	if(!is_method("PUBLISH|SUBSCRIBE"))
		return;

	if(is_method("SUBSCRIBE") && $hdr(Event)=="message-summary") 
	{
		route(TOVOICEMAIL);
		# returns here if no voicemail server is configured
		sl_send_reply("404", "No voicemail service");
		exit;
	}

#!ifdef WITH_PRESENCE
	if (!t_newtran()) 
	{
		sl_reply_error();
		exit;
	}

	if(is_method("PUBLISH")) 
	{
		xlog("===================================PUBLISH=======================================");
		handle_publish();
		t_release();
	} 
	else if(is_method("SUBSCRIBE")) 
	{
		xlog("===================================SUBSCRIBE=======================================");
		#handle_subscribe();
		handle_subscribe();
		t_release();
	}
	exit;
#!endif
	
	# if presence enabled, this part will not be executed
	if (is_method("PUBLISH") || $rU==$null) 
	{
		sl_send_reply("404", "Not here");
		exit;
	}
	return;

}



# IP authorization and user uthentication
route[AUTH] {


#!ifdef WITH_AUTH

#!ifdef WITH_IPAUTH
	if((!is_method("REGISTER")) && allow_source_address()) {


		# source IP allowed
		return;
	}
#!endif


	#if (is_method("REGISTER") && from_uri==myself)
	if (is_method("REGISTER"))
	{

		# authenticate requests
		if (!auth_check("$fd", "subscriber", "1")) {



			auth_challenge("$fd", "0");
			exit;
		}
		else
		{
		  xlog("==============REGISTER======$fu======$fd============");
		}
		# user authenticated - remove auth header
		if(!is_method("REGISTER|PUBLISH"))
			consume_credentials();
	}

	# a local destination, otherwise deny, not an open relay here

	#if (from_uri!=myself && uri!=myself) 
	if (from_uri!=myself)
	{
		#route to fs with gw header
		if(is_method("INVITE"))
		{
			append_hf("DVP-ORIGINATION-TYPE: GATEWAY\r\n");
			#sl_send_reply("403","Not relaying");
			#exit;
		}
	}
	else
	{
		if(is_method("INVITE"))
                {

			append_hf("DVP-ORIGINATION-TYPE: PUBLIC_USER\r\n");
		}
		
	}





#!endif

	return;
}

# Caller NAT detection

route[NATDETECT] 
{
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>--------NATDETECT---43 \033[0m \n");
force_rport();
#!ifdef WITH_NAT
#	force_rport();
	if (nat_uac_test("19")) 
	{
		if (is_method("REGISTER")) 
		{
			fix_nated_register();
		} 
		else 
		{
			if(is_first_hop())
				set_contact_alias();
		}
		setflag(FLT_NATS);
	}
#!endif
#!ifdef WITH_WEBSOCKETS
  if (nat_uac_test(64)) {
    # Do NAT traversal stuff for requests from a WebSocket
    # connection - even if it is not behind a NAT!
    # This won't be needed in the future if Kamailio and the
    # WebSocket client support Outbound and Path.
xlog("L_ERR", "Error aliasing contact------MMMMMMMMMM\n");
#    force_rport();
    if (is_method("REGISTER"))
        {
        xlog("L_ERR", "Error aliasing contact-----NNNNNNN\n");
        fix_nated_register();
        }
        else
        {
        #if (!add_contact_alias()) {
        xlog("L_ERR", "Error aliasing contact <$ct>\n");
        #sl_send_reply("400", "Bad Request");
        if(is_first_hop())
        set_contact_alias();
      #  exit;
        }
        setflag(FLT_NATS);

  }
#!endif

	return;
}

# RTPProxy control and singaling updates for NAT traversal
route[NATMANAGE] 
{
	xlog ("\033[32m ----------------------------------NATMANAGE-------------------------------- \033[0m \n");
	#!ifdef WITH_NAT
	if (is_request()) 
	{
		if(has_totag()) 
		{
			if(check_route_param("nat=yes")) 
			{
				setbflag(FLB_NATB);
			}
		}
	}
	if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB)))
		return;
xlog ("\033[32m ----------------------------------NATMANAGE------rtpproxy_manage-------------------------- \033[0m \n");
	rtpproxy_manage("co");
#	rtpproxy_manage();
#	rtpengine_manage();
	if (is_request()) 
	{
		if (!has_totag()) 
		{
			if(t_is_branch_route()) 
			{
				add_rr_param(";nat=yes");
			}
		}
	}
	if (is_reply()) 
	{
		if(isbflagset(FLB_NATB)) 
		{
			if(is_first_hop())
				set_contact_alias();
		}
	}
	#!endif
	return;
}

# URI update for dialog requests
route[DLGURI] 
{
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>--------DLGURI---56 \033[0m \n");
#!ifdef WITH_NAT
	if(!isdsturiset()) {
		handle_ruri_alias();
	}
#!endif
	return;
}

# Routing to foreign domains
route[SIPOUT] 
{
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>--------SIPOUT---58 \033[0m \n");
	if (uri==myself) return;

	append_hf("P-hint: outbound\r\n");
	xlog ("\033[32m >>>>>>>>>>>>>>>>>>>--------SIPOUT--ROUTE(RELAY)---- \033[0m \n");
	route(RELAY);
	exit;
}

# PSTN GW routing
route[PSTN] 
{
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>--------PSTN---59 \033[0m \n");
#!ifdef WITH_PSTN
	# check if PSTN GW IP is defined
	if (strempty($sel(cfg_get.pstn.gw_ip))) 
	{
		xlog("SCRIPT: PSTN rotuing enabled but pstn.gw_ip not defined\n");
		return;
	}

	# route to PSTN dialed numbers starting with '+' or '00'
	#     (international format)
	# - update the condition to match your dialing rules for PSTN routing
	if(!($rU=~"^(\+|00)[1-9][0-9]{3,20}$"))
		return;

	# only local users allowed to call
	if(from_uri!=myself) 
	{
		sl_send_reply("403", "Not Allowed");
		exit;
	}

	if (strempty($sel(cfg_get.pstn.gw_port))) 
	{
		$ru = "sip:" + $rU + "@" + $sel(cfg_get.pstn.gw_ip);
	}
	else 
	{
		$ru = "sip:" + $rU + "@" + $sel(cfg_get.pstn.gw_ip) + ":"
					+ $sel(cfg_get.pstn.gw_port);
	}

	route(RELAY);
	exit;
#!endif

	return;
}


# XMLRPC routing
#!ifdef WITH_XMLRPC
route[XMLRPC] 
{
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>--------XMLRPC---64 \033[0m \n");
	# allow XMLRPC from localhost
	if ((method=="POST" || method=="GET")
			&& (src_ip==127.0.0.1)) 
	{
		# close connection only for xmlrpclib user agents (there is a bug in
		# xmlrpclib: it waits for EOF before interpreting the response).
		if ($hdr(User-Agent) =~ "xmlrpclib")
			set_reply_close();
		set_reply_no_connect();
		dispatch_rpc();
		exit;
	}
	send_reply("403", "Forbidden");
	exit;
}
#!endif

# Routing to voicemail server
route[TOVOICEMAIL] {
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-------TOVOICEMAIL---66 \033[0m \n");
#!ifdef WITH_VOICEMAIL
	if(!is_method("INVITE|SUBSCRIBE"))
		return;

	# check if VoiceMail server IP is defined
	if (strempty($sel(cfg_get.voicemail.srv_ip))) 
	{
		xlog("SCRIPT: VoiceMail rotuing enabled but IP not defined\n");
		return;
	}
	if(is_method("INVITE")) 
	{
		if($avp(oexten)==$null)
			return;
		$ru = "sip:" + $avp(oexten) + "@" + $sel(cfg_get.voicemail.srv_ip)
				+ ":" + $sel(cfg_get.voicemail.srv_port);
	} 
	else 
	{
		if($rU==$null)
			return;
		$ru = "sip:" + $rU + "@" + $sel(cfg_get.voicemail.srv_ip)
				+ ":" + $sel(cfg_get.voicemail.srv_port);
	}
	route(RELAY);
	exit;
#!endif

	return;
}
# Manage outgoing branches
branch_route[MANAGE_BRANCH] 
{
xlog ("L_NOTICE" , "\033[32m >>>>>>>>>>>>>>>>>>>-------MANAGE_BRANCH---70  \033[0m \n");
	xdbg("new branch [$T_branch_idx] to $ru\n");
	route(NATMANAGE);
}

# Manage incoming replies
onreply_route[MANAGE_REPLY] {
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-------MANAGE_REPLY---71  \033[0m \n");
	xdbg("incoming reply\n");
	if(status=~"[12][0-9][0-9]")
		route(NATMANAGE);
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-------MANAGE_FAILURE---72  \033[0m \n");

        route(NATMANAGE);

        if (t_is_canceled()) {
                exit;
        }

#!ifdef WITH_BLOCK3XX
        # block call redirect based on 3xx replies.
        if (t_check_status("3[0-9][0-9]")) {
                t_reply("404","Not found");
                exit;
        }
#!endif

#!ifdef WITH_VOICEMAIL
        # serial forking
        # - route to voicemail on busy or no answer (timeout)
        if (t_check_status("486|408")) {
                $du = $null;
                route(TOVOICEMAIL);
                exit;
        }
#!endif

}


#!ifdef WITH_WEBSOCKETS
onreply_route {
  if ((($Rp == MY_WS_PORT || $Rp == MY_WSS_PORT)
    && !(proto == WS || proto == WSS)) || $Rp == MY_MSRP_PORT) {
    xlog("L_WARN", "SIP response received on $Rp\n");
    drop;
    exit;
  }
 
  if (nat_uac_test(64)) {
    # Do NAT traversal stuff for replies to a WebSocket connection
    # - even if it is not behind a NAT!
    # This won't be needed in the future if Kamailio and the
    # WebSocket client support Outbound and Path.
    add_contact_alias();
  }
}

##--- Achintha commented ---
#-#!ifdef WITH_FREESWITCH
## Test if coming from Asterisk
#route[FROMFREESWITCH] {
#xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-------FROMFREESWITCH_CONTEXT >>>>>>$ru>>>>>>>$fu>>>>>>>>--- \033[0m \n");
#	if($si==$sel(cfg_get.fs.bindip)
#			&& $sp==$sel(cfg_get.fs.bindport))
#		return 1;
#	return -1;
#}
 
## Send to Asterisk
#route[TOFREESWITCH] {
#	$du = "sip:" + $sel(cfg_get.fs.bindip) + ":" + $sel(cfg_get.fs.bindport);
#xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-------TOFREESWITCH>>>>>>$du >>>>>>>--- \033[0m \n");
#	route(RELAY);
#	exit;
#}
 
## Forward REGISTER to Asterisk
#route[REGFWD] {
#	if(!is_method("REGISTER"))
#	{
#		return;
#	}
#	$var(rip) = $sel(cfg_get.fs.bindip);
#	$uac_req(method)="REGISTER";
#	$uac_req(ruri)="sip:" + $var(rip) + ":" + $sel(cfg_get.fs.bindport);
#	$uac_req(furi)="sip:" + $au + "@" + $var(rip);
#	$uac_req(turi)="sip:" + $au + "@" + $var(rip);
#	$uac_req(hdrs)="Contact: <sip:" + $au + "@"
#			+ $sel(cfg_get.kamailio.bindip)
#				+ ":" + $sel(cfg_get.kamailio.bindport) + ">\r\n";
#	if($sel(contact.expires) != $null)
#		$uac_req(hdrs)= $uac_req(hdrs) + "Expires: " + $sel(contact.expires) + "\r\n";
#	else
#		$uac_req(hdrs)= $uac_req(hdrs) + "Expires: " + $hdr(Expires) + "\r\n";
#	uac_req_send();
#}
#-#!endif





#- aCHINTHA CHANGED 1_xhttp:request
event_route[xhttp:request] {
	xlog("==================================================XHTTP REQUEST=====================================================\n");
	xdbg("===== xhttp: request [$rv] $rm => $hu\n");

#	if (!www_authorize("xcap", "subscriber"))
#	{
#	xlog ("\033[32m >>>>>>>>>>>>>>>>>>>-------www_challenge--->>>>>>>>>>>>--- \033[0m \n");
#		www_challenge("xcap", "0");
#		exit;
#	}

	if($hu=~"^/xcap-root/")
	{

		if (!www_authorize("xcap", "subscriber"))
        	{
                www_challenge("xcap", "0");
                exit;
        	}


		xlog("==================================================XCAP ROOT REQUEST=====================================================\n");
		set_reply_close();
		set_reply_no_connect();
		# xcap ops
		$xcapuri(u=>data) = $hu;
		if($xcapuri(u=>xuid)=~"^sip:.+@.+")
			$var(uri) = $xcapuri(u=>xuid);
		else if($xcapuri(u=>xuid)=~".+@.+")
			$var(uri) = "sip:" + $xcapuri(u=>xuid);
		else
			$var(uri) = "sip:"+ $xcapuri(u=>xuid) + "@" + $Ri;
		xlog("===== xhttp: $xcapuri(u=>auid) : $xcapuri(u=>xuid)\n");
		if($xcapuri(u=>auid)=="xcap-caps")
		{
			$var(xbody) =
"<?xml version='1.0' encoding='UTF-8'?>
<xcap-caps xmlns='urn:ietf:params:xml:ns:xcap-caps'>
  <auids>
    <auid>rls-services</auid>
    <auid>pidf-manipulation</auid>
    <auid>xcap-caps</auid>
    <auid>resource-lists</auid>
    <auid>pres-rules</auid>
    <auid>org.openmobilealliance.pres-rules</auid>
  </auids>
  <extensions>
  </extensions>
  <namespaces>
    <namespace>urn:ietf:params:xml:ns:rls-services</namespace>
    <namespace>urn:ietf:params:xml:ns:pidf</namespace>
    <namespace>urn:ietf:params:xml:ns:xcap-caps</namespace>
    <namespace>urn:ietf:params:xml:ns:resource-lists</namespace>
    <namespace>urn:ietf:params:xml:ns:pres-rules</namespace>
  </namespaces>
</xcap-caps>";
			xhttp_reply("200", "ok", "application/xcap-caps+xml",
					"$var(xbody)");
			exit;
		}

        # be sure auth user access only its documents
        if ($au!=$(var(uri){uri.user})) {
           xhttp_reply("403", "Forbidden", "text/html",
                  "<html><body>$si:$sp</body></html>");
         exit;
      }


		switch($rm) {
			case "PUT":
				xlog("==================================================XHTTP PUT=====================================================");
				xcaps_put("$var(uri)", "$hu", "$rb");
				if($xcapuri(u=>auid)=~"pres-rules")
				{
					xlog("===== xhttp put: refreshing watchers for $var(uri)\n");
					pres_update_watchers("$var(uri)", "presence");
					pres_refresh_watchers("$var(uri)", "presence", 1);
				}
				exit;
			break;
			case "GET":
				xlog("==================================================XHTTP GET=====================================================");
				xlog("===== xhttp: get $var(uri) => $hu\n");
				xcaps_get("$var(uri)", "$hu");
				exit;
			break;
			case "DELETE":
				xcaps_del("$var(uri)", "$hu");
				if($xcapuri(u=>auid)=~"pres-rules")
				{
					xlog("===== xhttp del: refreshing watchers for $var(uri)\n");
					pres_update_watchers("$var(uri)", "presence");
					pres_refresh_watchers("$var(uri)", "presence", 1);
				}
				exit;
			break;
		}
	}

	else if
	{
  set_reply_close();
  set_reply_no_connect();
 
  if ($Rp != MY_WS_PORT
#!ifdef WITH_TLS
      || $Rp != MY_WSS_PORT
#!endif
  ) {
    xlog("L_WARN", "HTTP request received on $Rp\n");
    xhttp_reply("403", "Forbidden", "", "");
    exit;
  }
 
  xlog("L_DBG", "HTTP Request Received\n");
 
  if ($hdr(Upgrade)=~"websocket"
      && $hdr(Connection)=~"Upgrade"
      && $rm=~"GET") {
        
    if (ws_handle_handshake())
    {
      # Optional... cache some information about the
      # successful connection
	 xlog("L_DBG", "successful connection\n");
      exit;
    }
  }
 
  xhttp_reply("404", "Not Found", "", "");
exit;
	}

	# http ops
	xhttp_reply("200", "ok", "text/html",
				"<html><body>OK: $si:$sp</body></html>");
	exit;
}


#-Achintha inserted

#event_route[xhttp:request] {
#  set_reply_close();
#  set_reply_no_connect();
# 
##  if ($Rp != MY_WS_PORT
#-#!ifdef WITH_TLS
#      && $Rp != MY_WSS_PORT
#-#!endif
#  ) {
#    xlog("L_WARN", "HTTP request received on $Rp\n");
#    xhttp_reply("403", "Forbidden", "", "");
#    exit;
#  }
# 
#  xlog("L_DBG", "HTTP Request Received\n");
# 
#  if ($hdr(Upgrade)=~"websocket"
#      && $hdr(Connection)=~"Upgrade"
#      && $rm=~"GET") {
# 
#    # Validate Host - make sure the client is using the correct
#    # alias for WebSockets
#    # Sasa: commented out, see http://sip-router.1086192.n5.nabble.com/Testing-the-Websocket-module-with-sipml5-org-td65069.html
#    #if ($hdr(Host) == $null || !is_myself("sip:" + $hdr(Host))) {
#    #  xlog("L_WARN", "Bad host $hdr(Host)\n");
#    #  xhttp_reply("403", "Forbidden", "", "");
#    #  exit;
#    #}
# 
#    # Optional... validate Origin - make sure the client is from an
#    # authorised website.  For example,
#    #
#    # if ($hdr(Origin) != "http://communicator.MY_DOMAIN"
#    #     &amp;&amp; $hdr(Origin) != "https://communicator.MY_DOMAIN") {
#    #  xlog("L_WARN", "Unauthorised client $hdr(Origin)\n");
#    #  xhttp_reply("403", "Forbidden", "", "");
#    #  exit;
#    # }
# 
#    # Optional... perform HTTP authentication
# 
#    # ws_handle_handshake() exits (no further configuration file
#    # processing of the request) when complete.
#    if (ws_handle_handshake())
#    {
#      # Optional... cache some information about the
#      # successful connection
#      exit;
#    }
#  }
# 
#  xhttp_reply("404", "Not Found", "", "");
#}
 
event_route[websocket:closed] {
  xlog("L_INFO", "WebSocket connection from $si:$sp has closed\n");
}
#!endif
 
#!ifdef WITH_MSRP
event_route[msrp:frame-in] {
  msrp_reply_flags("1");
 
  if ((($Rp == MY_WS_PORT || $Rp == MY_WSS_PORT)
    && !(proto == WS || proto == WSS)) && $Rp != MY_MSRP_PORT) {
    xlog("L_WARN", "MSRP request received on $Rp\n");
    msrp_reply("403", "Action-not-allowed");
    exit;
  }
 
  if (msrp_is_reply()) {
    msrp_relay();
  } else if($msrp(method)=="AUTH") {
    if($msrp(nexthops)>0) {
      msrp_relay();
      exit;
    }
 
    if (!www_authenticate("MY_DOMAIN", "subscriber",
          "$msrp(method)")) {
      if (auth_get_www_authenticate("MY_DOMAIN", "1",
              "$var(wauth)")) {
        msrp_reply("401", "Unauthorized",
              "$var(wauth)");
      } else {
        msrp_reply("500", "Server Error");
      }
      exit;
    }
 
    if ($hdr(Expires) != $null) {
      $var(expires) = (int) $hdr(Expires);
      if ($var(expires) < MSRP_MIN_EXPIRES) {
        msrp_reply("423", "Interval Out-of-Bounds",
          "Min-Expires: MSRP_MIN_EXPIRES\r\n");
        exit;
      } else if ($var(expires) > MSRP_MAX_EXPIRES) {
        msrp_reply("423", "Interval Out-of-Bounds",
          "Max-Expires: MSRP_MAX_EXPIRES\r\n");
        exit;
      }
    } else {
      $var(expires) = MSRP_MAX_EXPIRES;
    }
 
    $var(cnt) = $var(cnt) + 1;
    pv_printf("$var(sessid)", "s.$(pp).$(var(cnt)).$(RANDOM)");
    $sht(msrp=>$var(sessid)::srcaddr) = $msrp(srcaddr);
    $sht(msrp=>$var(sessid)::srcsock) = $msrp(srcsock);
    $shtex(msrp=>$var(sessid)) = $var(expires) + 5;
    # - Use-Path: the MSRP address for server + session id
    $var(hdrs) = "Use-Path: msrps://MY_IP_ADDR:MY_MSRP_PORT/"
          + $var(sessid) + ";tcp\r\n"
          + "Expires: " + $var(expires) + "\r\n";
    msrp_reply("200", "OK", "$var(hdrs)");
  } else if ($msrp(method)=="SEND" || $msrp(method)=="REPORT") {
    if ($msrp(nexthops)>1) {
      if ($msrp(method)!="REPORT") {
        msrp_reply("200", "OK");
      }
      msrp_relay();
      exit;
    }
    $var(sessid) = $msrp(sessid);
    if ($sht(msrp=>$var(sessid)::srcaddr) == $null) {
      # one more hop, but we don't have address in htable
      msrp_reply("481", "Session-does-not-exist");
      exit;
    } else if ($msrp(method)!="REPORT") {
      msrp_reply("200", "OK");
    }
    msrp_relay_flags("1");
    msrp_set_dst("$sht(msrp=>$var(sessid)::srcaddr)",
        "$sht(msrp=>$var(sessid)::srcsock)");
    msrp_relay();
  } else {
    msrp_reply("501", "Request-method-not-understood");
  }
}
#!endif
